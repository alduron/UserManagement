<#
    .NOTES
    --------------------------------------------------------------------------------
     Code generated by:  SAPIEN Technologies, Inc., PowerShell Studio 2016 v5.2.128
     Generated on:       9/14/2016 4:56 PM
     Generated by:       rodell
     Organization:       One Technologies
    --------------------------------------------------------------------------------
    .DESCRIPTION
        Script generated by PowerShell Studio 2016
#>
	
	Function Get-OPSUserManagementVersion {
		[CmdletBinding()]
		param (
		)
		BEGIN { }
		PROCESS { }
		END { }
	}
	
	Function Revoke-UserAccess {
	    <#
	    .SYNOPSIS
	        Revoke a user's AD access and log the results
	    .DESCRIPTION
	        This function will determine if it's currently running in the PCI environment and then
	        match a SAMAccountName from AD. This function will then execute the following:
	            1) Check for an existing restore file for the user, steps are skipped in certain 
	               conditions
	            2) Query O365 for current license status and cache the result
	            3) Get a copy of both AD and O365 photos
	            4) Format data into a custom PSObject for export
	            5) Export the PSObject to XML
	            6) Remove user from all groups they are associated with
	            7) Move the user to the disabled OU
	            8) Disable the user account
	            9) Update the description on the account
	           10) Set mail to forward to manager's address
	           11) Remote start the AD/O365 sync scheduled task
	    .EXAMPLE
	        Revoke-UserAccess -User SAMAccountName -Ticket "SD-000"
	    .EXAMPLE
	        Revoke-UserAccess -User SAMAccountName -Ticket "Verbal request from HR"
	    .PARAMETER User
	        The SAMAccountName of the user to be revoked
	    .PARAMETER Ticket
	        The Jira ticket number of the request. This is a plain string for special requests
	    #>
		[CmdletBinding()]
		param (
			[Parameter(Mandatory = $True, ValueFromPipeline = $False)]
			[String]$User,
			[String]$Ticket,
            [Switch]$SkipSync
		)
		BEGIN {
			try {
				[xml]$config = Get-OTConfig
			} catch {
				Write-ToConsole "Could not import config file" -ErrorMessage $_.Exception.Message -Type ERR
			}
			$Log = $config.Config.Globals.LogRoot + $config.Config.Modules.UserManagement.UserAccess.Revoke.LogFile
			$ExportFile = $Config.Config.Globals.LogRoot + $config.Config.Modules.UserManagement.UserAccess.RestoreFolder + "\$User-Restore.xml"
			$HasFile = Test-Path $ExportFile
			$ExportData = New-Object -TypeName PSObject
			New-LogEntry -Path $Log -Comment "on user $User with ticket $Ticket" -JobType "Revoke"
		}
		PROCESS {
			#Query AD for user
			try {
				$UserAD = Get-ADUser -Identity $User -Properties * -ErrorAction Stop
				$Domain = ($UserAD.DistinguishedName -split ',DC=')[1]
				$PCI = $Domain -match "DMZ|TEST|MGMT|PROD"
				$UserOU = $UserAD.CanonicalName.Replace("$Domain.local/", "").Replace($UserAD.DisplayName, "")
				Add-ToLog $Log "Located $User in $UserOU" -Type INF -Console
			} catch {
				Add-ToLog $Log "A match for $User was not located in Active Directory" -ErrorMessage $_.Exception.Message -Type ERR -Console
				exit
				
			}
			
			#Query MSOLicense
			if (!($PCI) -and !($HasFile)) {
				try {
					$UserMSOL = Get-O365License $User
					Add-ToLog $Log "Gathered MSOL license info" -Type INF
				} catch {
					Add-ToLog $Log "Could not gather MSOL License information" -ErrorMessage $_.Exception.Message -Type ERR -Console
				}
			} else {
				Add-ToLog $Log "A restore file has been detected. Skipping MSO license query" -Type INF -Console
			}
			
			#Get a copy of photos
			if (!($PCI) -and !($HasFile)) {
				try {
					$UserPhotos = Get-CorpPhotos -User $User
					Add-ToLog $Log "Gathered photo data" -Type INF
				} catch {
					Add-ToLog $Log "Could not gather photo data" -ErrorMessage $_.Exception.Message -Type ERR -Console
				}
			} else {
				Add-ToLog $Log "A restore file has been detected. Skipping photo export" -Type INF -Console
			}
			
			#Format data for export
			$ExportData | Add-Member -MemberType NoteProperty -Name ADObject -Value $UserAD
			if (!($PCI) -and !($HasFile)) {
				try {
					if ($MSOLUser) { $ExportData | Add-Member -MemberType NoteProperty -Name MSOLObject -Value $UserMSOL }
					if ($UserPhotos) { $ExportData | Add-Member -MemberType NoteProperty -Name PhotoObject -Value $UserPhotos }
					Add-ToLog $Log "Formatting restore data" -Type INF
				} catch {
					Add-ToLog $Log "Could not format restore data" -ErrorMessage $_.Exception.Message -Type ERR -Console
				}
			} else {
				Add-ToLog $Log "A restore file has been detected. Skipping photo format" -Type INF -Console
			}
			
			#Export PSO
			if (!$HasFile) {
				try {
					New-File $ExportFile | Out-Null
					$ExportData | Export-Clixml -Path $ExportFile -ErrorAction Stop | Out-Null
					Add-ToLog $Log "Exporting $User to $ExportFile for restoration" -Type INF -Console
				} catch {
					Add-ToLog $Log "Failed to export $User to $ExportFile" -ErrorMessage $_.Exception.Message -Type INF
				}
			} else {
				Add-ToLog $Log "A restore file has been detected. Skipping restore file save" -Type INF -Console
			}
			
			#Remove all groups
			foreach ($Group in $UserAD.MemberOf) {
				try {
					Remove-ADGroupMember $Group $UserAD.SamAccountName -Confirm:$false
					Add-ToLog $Log "Removed $User from $Group" -Type INF
				} catch {
					Add-ToLog $Log "Could not remove $User from $Group" -ErrorMessage $_.Exception.Message -Type WRN -Console
				}
			}
			
			#Move user to disabled OU
			try {
				Move-ADObject $UserAD.DistinguishedName -TargetPath "$($config.Config.Modules.UserManagement.UserAccess.DisabledOU.replace("::DOMAINOU::", $Domain.ToUpper()).replace("::DOMAIN::", $Domain))"
				Add-ToLog $Log "$User has been moved to the Disabled Users OU" -Type INF
			} catch {
				Add-ToLog $Log "$User could not be moved to the Disabled Users OU" -ErrorMessage $_.Exception.Message -Type ERR -Console
			}
			
			#Disable account
			try {
				Disable-ADAccount $User
				Add-ToLog $Log "$User has been disabled" -Type INF -Console
			} catch {
				Add-ToLog $Log "Could not disable $User" -ErrorMessage $_.Exception.Message -Type ERR -Console
			}
			
			#Set description on user
			try {
				Set-ADUser $User -Description "Disabled on $(Get-Date -Format "MM/dd/yy"). Ticket #:$Ticket"
				Add-ToLog $Log "Description updated" -Type INF
			} catch {
				Add-ToLog $Log "Could not alter the description for $User" -ErrorMessage $_.Exception.Message -Type ERR -Console
			}
			
			#Set Mail forwarding
			if (!$PCI) {
				try {
					$ManagerAD = Get-ADUser $UserAd.Manager
					Add-MailForwarding -ToUser $ManagerAD.SamAccountName -FromUser $UserAD.SamAccountName
					Add-ToLog $Log "$($UserAD.SamAccountName) emails are now being forwarded to $($ManagerAD.SamAccountName)" -Type INF -Console
				} catch {
					Add-ToLog $Log "Could not enable forwarding" -ErrorMessage $_.Exception.Message -Type ERR -Console
				}
			}
			
			#Run O365 Sync job
			if (!$PCI -and !$SkipSync) {
				try {
					Invoke-ScheduledTask -Server $Config.Config.Modules.UserManagement.UserAccess.O365SyncServer -TaskName $config.Config.Modules.UserManagement.UserAccess.O365TaskName -Wait
				} catch {
					Add-ToLog $Log "Task `"$($config.Config.Modules.UserManagement.UserAccess.O365TaskName)`" on $($Config.config.Modules.UserManagement.UserAccess.O365SyncServer) did not run successfully" -ErrorMessage $_.Exception.Message -Type ERR -Console
				}
			}
		}
		END {
		}
	}
	
	Function Restore-UserAccess {
	    <#
	    .SYNOPSIS
	        Restore a user's AD access from a XML backup and log the results
	    .DESCRIPTION
	        This function will determine if it's currently runnin in the PCI zone and perform the
	        following steps accordingly:
	            1) Import the XML restore file that was exported from Revoke-UserAccess
	            2) Check to see if the account already exists in AD, pass to New-UserAccess if not
	            3) Move the user back to their original OU
	            4) Restore each group membership that was removed from the user previously
	            5) Replace the description with the cached description
	            6) Remove the mail forwarding that was placed on the user's manager
	            7) Re-Enable the user
	            8) Reset the expiration date of the user
	            9) Restore both O365 and AD photos
	    .PARAMETER User
	        The SAMAccount name of the user that will be restored from file
	    .PARAMETER Ticket
	        The Jira ticket number of the request. This is a plain string for special requests
	    .EXAMPLE
	        Restore-UserAccess -User SAMAccountName -Ticket "SD-000"
	    .EXAMPLE
	        Restore-UserAccess -User SAMAccountName -Ticket "Verbal request from HR"
	    .LINK
	    .NOTES
	    #>
		[CmdletBinding()]
		param (
			[Parameter(Mandatory = $True, ValueFromPipeline = $False)]
			[String]$User,
			[String]$Ticket
		)
		BEGIN {
			#Import config and create log file
			try {
				[xml]$config = Get-OTConfig
			} catch {
				Write-ToConsole "Could not import config file" -ErrorMessage $_.Exception.Message -Type ERR
			}
			$Log = $config.Config.Globals.LogRoot + $config.Config.Modules.UserManagement.UserAccess.Restore.LogFile
			New-LogEntry $Log "on user $User with ticket $Ticket" -JobType "Restore"
			
			#Import restore file
			try {
				$ImportFile = $Config.Config.Globals.LogRoot + $config.Config.Modules.UserManagement.UserAccess.RestoreFolder + "\$User-Restore.xml"
				$RestoreObject = Import-Clixml $ImportFile
				Add-ToLog $Log "Located $User restore file at $ImportFile" -Type INF
			} catch {
				Add-ToLog $Log "Could not locate a restore file for $User. File should have been located at $ImportFile" -Type ERR -Console
			}
		}
		PROCESS {
			#Check to see if user exists in AD
			$UserAD = Get-ADUser -Identity $User -Properties * -ErrorAction Stop
			$Domain = ($UserAD.DistinguishedName -split ',DC=')[1]
			$PCI = $Domain -match "DMZ|TEST|MGMT|PROD"
			
			#
			if ($UserAD) {
				Add-ToLog $Log "A match for $User was located in Active Directory. Restoring user account" -Type INF
				
				#Move user to OU
				try {
					$OldOU = $RestoreObject.ADObject.DistinguishedName.Replace("CN=$($RestoreObject.ADObject.DisplayName),", "")
					Move-ADObject $UserAD.DistinguishedName -TargetPath $OldOU
					Add-ToLog $Log "$User has been moved to $OldOu" -Type INF
				} catch {
					Add-ToLog $Log "$User could not be moved to $OldOU" -ErrorMessage $_.Exception.Message -Type ERR -Console
				}
				
				#Restore group memberships
				foreach ($Group in $RestoreObject.ADObject.MemberOf) {
					try {
						Add-ADGroupMember $Group $UserAD.SamAccountName -Confirm:$false
						Add-ToLog $Log "Added $User to $Group" -Type INF
					} catch {
						Add-ToLog $Log "Could not add $User to $Group" -ErrorMessage $_.Exception.Message -Type WRN -Console
					}
				}
				
				#Replace Description
				try {
					Set-ADUser $User -Description $RestoreObject.ADObject.Description
					Add-ToLog $Log "Description updated" -Type INF
				} catch {
					Add-ToLog $Log "Could not alter the description for $User" -ErrorMessage $_.Exception.Message -Type WRN -Console
				}
				
				#Remove mail forwarding
				if (!$PCI) {
					try {
						$ManagerAD = Get-ADUser $RestoreObject.ADObject.Manager
						Remove-MailForwarding -ToUser $ManagerAD.SamAccountName -FromUser $UserAD.SamAccountName
						Add-ToLog $Log "Forwarding of $($UserAD.SamAccountName) emails to $($ManagerAD.SamAccountName) has been removed" -Type INF -Console
					} catch {
						Add-ToLog $Log "Could not remove forwarding" -ErrorMessage $_.Exception.Message -Type ERR -Console
					}
				}
				
				#Enable user
				try {
					Enable-ADAccount $User
					Add-ToLog $Log "$User has been enabled" -Type INF -Console
				} catch {
					Add-ToLog $Log "Could not enable $User" -ErrorMessage $_.Exception.Message -Type WRN -Console
				}
				
				#Reset expiration
				try {
					Clear-ADAccountExpiration $User
					Add-ToLog $Log "Reset user expiration" -Type INF
				} catch {
					Add-ToLog $Log "Could not reset user expiration" -ErrorMessage $_.Exception.Message -Type ERR -Console
				}
				
				#Restore photos
				if ((!$PCI) -and ($RestoreObject.PhotoObject.O365Photo -ne $null)) {
					try {
						Invoke-ScheduledTask -Server $Config.Config.Modules.UserManagement.UserAccess.O365SyncServer -TaskName $config.Config.Modules.UserManagement.UserAccess.O365TaskName -Wait
						Set-CorpPhotos -User $User -ADByte $RestoreObject.PhotoObject.ADPhoto -O365Byte $RestoreObject.PhotoObject.O365Photo
						Add-ToLog $Log "Added photos back into AD and O365" -Type INF
					} catch {
						Add-ToLog $Log "Could not re-add photos" -ErrorMessage $_.Exception.Message -Type WRN -Console
					}
				}
				
			} else {
				Add-ToLog $Log "No match for $User was located in Active Directory. Creating a new account" -Type WRN -Console
				New-UserAccess $User $Ticket
			}
		}
		END { }
	}
	
	Function New-UserAccess {
	    <#
	    .SYNOPSIS
	        Creates a new user account in AD. Not currenlty functional
	    .DESCRIPTION
	        Will update once function is working
	    .PARAMETER 
	    .PARAMETER 
	    .EXAMPLE
	    .LINK
	    .NOTES
	    #>
		[CmdletBinding()]
		param (
			[Parameter(Mandatory = $True, ValueFromPipeline = $False)]
			[String]$SamAccountName,
			[String]$FirstName,
			[String]$LastName,
			[String]$Password,
			[String]$CopyUser,
			[String]$Ticket,
			[Parameter(Mandatory = $False, ValueFromPipeline = $False)]
			[String]$Manager,
			[String]$Title,
			[String]$Department,
			[Switch]$PCI,
			[Switch]$TrustedVPN,
			[Switch]$ForcePasswordChange,
			[Switch]$RestrictPasswordChange,
			[Switch]$RemovePasswordExpiration,
			[Switch]$CreateAsDisabled,
			[Switch]$EnableMailbox,
			[Switch]$IsServiceAccount
		)
		BEGIN {
			#Import config and create log file
			try {
				[xml]$config = Get-OTConfig
			} catch {
				Write-ToConsole "Could not import config file" -ErrorMessage $_.Exception.Message -Type ERR
			}
			$Log = $config.Config.Globals.LogRoot + $config.Config.Modules.UserManagement.UserAccess.New.LogFile
			New-LogEntry $Log "on user $User with ticket $Ticket" -JobType "New User"
			
			#Import restore file
			try {
				$ImportFile = $Config.Config.Globals.LogRoot + $config.Config.Modules.UserManagement.UserAccess.RestoreFolder + "\$User-Restore.xml"
				[xml]$RestoreObject = Get-Content $ImportFile
				Add-ToLog $Log "Located $User restore file at $ImportFile" -Type INF
			} catch {
				Add-ToLog $Log "Could not locate a restore file for $User. File should have been located at $ImportFile" -Type ERR -Console
			}
		}
		PROCESS {
			#
		}
		END { }
	}
	
	Function Set-O365License {
	    <#
	    .SYNOPSIS
	        Sets the O365 license for a user
	    .DESCRIPTION
	        Sets the licensing for a user in O365 which dictiates the tools available to each user.
	        See License Parameter for options
	    .PARAMETER User
	        The O365 UserPrincipalName of the user. This is usually SAMAccountName@onetechnologies.net
	    .PARAMETER License
	        A validated set of the following options:
	            Limited - A standard mail license that does not include Skype for Business
	            Standard - The standard OT License that includes Skype for Business, Outlook, and 
	                       standard programs
	            Pro - A license that includes all available applications
	    .EXAMPLE
	        Set-O365License -User SAMAccountName@onetechnologies.net -License STANDARD
	    .LINK
	    .NOTES
	    #>
		[CmdletBinding()]
		param (
			[Parameter(Mandatory = $True, ValueFromPipeline = $True)]
			[Microsoft.ActiveDirectory.Management.ADUser]$User,
			[Parameter(Mandatory = $True, ValueFromPipeline = $False)]
			[ValidateSet("LIMITED", "STANDARD", "PRO")]
			[String]$License,
			[Parameter(Mandatory = $False, ValueFromPipeline = $False)]
			[PsCredential]$Credentials
		)
		BEGIN {
			[xml]$config = Get-OTConfig
			$Log = $config.Config.Globals.LogRoot + $config.Config.Modules.UserManagement.O365License.LogFile
			Switch ($License) {
				"LIMITED"{ $LicenseString = "onetechnologiesO365:POWER_BI_STANDARD" }
				"STANDARD"{ $LicenseString = "onetechnologiesO365:ENTERPRISEPACK" }
				"PRO"{ $LicenseString = "onetechnologiesO365:POWER_BI_PRO" }
			}
			$WarningPreference = 'silentlycontinue'
			New-LogEntry $Log "for setting Office365 license" -JobType "O365 License Update" -Console
			
			Connect-CorpO365 -Credentials $Creds -ConnectMSOL -ErrorAction Stop
			Connect-CorpExchange
			
			$Changed = $False
		}
		PROCESS {
			$Changed = $True
			#Set User Localization
			try {
				Set-MsolUser -UserPrincipalName $User.UserPrincipalName -UsageLocation 'US' -ErrorAction Stop
				Add-ToLog $Log "$($User.SamAccountName)'s localization has been changed to US" -Type INF
			} catch {
				Add-ToLog $Log "$($User.SamAccountName)'s localization could not be changed to US" -ErrorMessage $_.Exception.Message -Type ERR -Console
			}
			
			#Set License
			try {
				Set-MsolUserLicense -UserPrincipalName $User.UserPrincipalName -AddLicenses $LicenseString -ErrorAction Stop
				Add-ToLog $Log "$($User.SamAccountName)'s license was set to $License($LicenseString)" -Type INF
			} catch {
				Add-ToLog $Log "$($User.SamAccountName)'s license could not be set to $License($LicenseString)" -ErrorMessage $_.Exception.Message -Type ERR -Console
			}
			
			#Clear extensionAttribute flag
			try {
				Set-ADUser -Identity $User -Clear extensionAttribute2
				Add-ToLog $Log "Removed extensionAttribute2 flag from $($User.SamAccountName)" -Type INF -Console
			} catch {
				Add-ToLog $Log "Could not clear extensionAttribute2 flag from $($User.SamAccountName)" -ErrorMessage $_.Exception.Message -Type ERR -Console
			}
			
			#Set litigation hold on mailbox
			try {
				Set-Mailbox -Identity $User.SamAccountName -LitigationHoldEnabled $true -LitigationHoldDuration Unlimited
				Add-ToLog $Log "Setting $($User.SamAccountName)'s litigation hold to True" -Type INF -Console
			} catch {
				Add-ToLog $Log "Could not set litigation hold status to True" -ErrorMessage $_.Exception.Message -Type ERR -Console
			}
		}
		END {
			if (!$Changed) {
				Add-ToLog $Log "All users are properly licensed" -Type INF -Console
			}
		}
	}
	
	Function Get-O365License {
	    <#
	    .SYNOPSIS
	        Gets the current O365 license information assigned to the user
	    .DESCRIPTION
	        Returns the current O365 license information in O365 format
	    .PARAMETER User
	        The O365 UserPrincipalName of the user. This is usually SAMAccountName@onetechnologies.net
	    .EXAMPLE
	        Get-O365License -User SAMAccountName@onetechnologies.net
	    .LINK
	    .NOTES
	    #>
		[CmdletBinding()]
		param (
			[Parameter(Mandatory = $True, ValueFromPipeline = $False)]
			[String]$User
		)
		BEGIN {
			#Get UserAD
			$UserAD = Get-ADUser $User
		}
		PROCESS {
			#Get User Localization
			$UserMSOL = Get-MSOLUser -UserPrincipalName $UserAD.UserPrincipalName -ErrorAction SilentlyContinue
		}
		END {
			return $UserMSOL
		}
	}
	
	Function Get-CorpPhotos {
	    <#
	    .SYNOPSIS
	        Get a PSObject containing both AD and O365 photos
	    .DESCRIPTION
	        This function returns a custom PSObject containing both AD and O365 photos. These photos
	        can optionally be exported as JPG files to a folder specified with -ToFolder
	    .PARAMETER User
	        The SAMAccountName of the user. UserPrincipalName is automatically pulled and used in 
	        retreiving O365 photo data
	    .PARAMETER ToFolder
	        An optional parameter used for exporting photo data to the specified folder path. Requires
	        a SMB folder path as string
	    .EXAMPLE
	        GEt-CorpPhotos -User SAMAccountName
	    .EXAMPLE
	        GEt-CorpPhotos -User SAMAccountName -ToFolder "C:\Users\UserName\Desktop\PhotoFolder"
	    .LINK
	    .NOTES
	    #>
		[CmdletBinding()]
		param (
			[Parameter(Mandatory = $True, ValueFromPipeline = $False)]
			[String]$User,
			[Parameter(Mandatory = $False, ValueFromPipeline = $False)]
			[String]$ToFolder
		)
		BEGIN {
			#Connect to O365
			Connect-CorpO365
		}
		PROCESS {
			#Export AD Photo
			$ADExport = Get-ADUser $User -properties SamAccountName, ThumbnailPhoto, UserPrincipalName
			
			#Export O365 Photo
			$O365Export = Get-UserPhoto $ADExport.UserPrincipalName -ErrorAction SilentlyContinue
			
			if ($ToFolder) {
				try {
				    #Save AD photo to file
				    New-item -Path "$ToFolder\$User-AD.jpg" -Type file -Force | Out-Null
				    $ADExport.thumbnailphoto | Set-Content ("$ToFolder\$User-AD.jpg") -Encoding byte -Force
				    Write-ToConsole "AD photo exported to $ToFolder" -Type INF
				    
				    #Save O365 photo to file
				    New-item -Path "$ToFolder\$User-O365.jpg" -Type file -Force | Out-Null
				    $O365Export.PictureData | Set-Content ("$ToFolder\$User-O365.jpg") -Encoding byte -Force
				    Write-ToConsole "O365 photo exported to $ToFolder" -Type INF
				} catch {
					Write-ToConsole "Could not export photos of $User to $ToFolder" -ErrorMessage $_.Exception.Message -Type INF
				}
			} else {
				#Set PSObject for export
				$ExportData = New-Object -TypeName PSObject
				
				#Populate PSObject
				$ExportData | Add-Member -MemberType NoteProperty -Name ADPhoto -Value $ADExport.ThumbnailPhoto
				$ExportData | Add-Member -MemberType NoteProperty -Name O365Photo -Value $O365Export.PictureData
				
				return $ExportData
			}
		}
		END {
		}
	}
	
	Function Set-CorpPhotos {
	    <#
	    .SYNOPSIS
	        Sets AD and O365 photo data from the sources provided
	    .DESCRIPTION
	        This function accepts either byte stream or file path and then uploads input into both 
	        AD and O365. This does not convert the badge photos to both platforms like the nightly
	        scheduled task. This is only for rehydration from previously exported photos.
	    .PARAMETER User
	        The SAMAccountName of the user that will receive the photo uploads. UserPrincipalName 
	        is automatically pulled for use with O365
	    .PARAMETER ADByte
	        A member of FromByte parameter set. This is a System Byte Array most commonly exported
	        to the user rehydration save file. Cannot be used in conjunction with FromFile parameter
	        set.
	    .PARAMETER O365Byte
	        A member of FromByte parameter set. This is a System Byte Array most commonly exported
	        to the user rehydration save file. Cannot be used in conjunction with FromFile parameter
	        set.
	    .PARAMETER ADFile
	        A member of FromFile parameter set. This is a SMB string path to the JPG that has been
	        exported via Get-CorpPhotos. Cannot be used in conjunction with FromByte parameter set.
	    .PARAMETER O365File
	        A member of FromFile parameter set. This is a SMB string path to the JPG that has been
	        exported via Get-CorpPhotos. Cannot be used in conjunction with FromByte parameter set.
	    .EXAMPLE
	        Set-CorpPhotos -User SAMAccountName -ADByte [System.Byte[]] -O365Byte [System.Byte[]]
	    .EXAMPLE
	        Set-CorpPhotos -User SAMAccountName -ADFile "C:\Users\User\Desktop\ADPicture.JPG" -O365Byte "C:\Users\User\Desktop\O365Picture.JPG"
	    .LINK
	    .NOTES
	    #>
		[CmdletBinding()]
		param (
			[Parameter(Mandatory = $True, ValueFromPipeline = $False)]
			[String]$User,
			[Parameter(ParameterSetName = 'FromByte', Mandatory = $True, ValueFromPipeline = $False)]
			[System.Byte[]]$ADByte,
			[Parameter(ParameterSetName = 'FromByte', Mandatory = $True, ValueFromPipeline = $False)]
			[System.Byte[]]$O365Byte,
			[Parameter(ParameterSetName = 'FromFile', Mandatory = $True, ValueFromPipeline = $False)]
			[String]$ADFile,
			[Parameter(ParameterSetName = 'FromFile', Mandatory = $True, ValueFromPipeline = $False)]
			[String]$O365File
		)
		BEGIN {
			#Initiate logging
			[xml]$config = Get-OTConfig
			$Log = $config.Config.Globals.LogRoot + $config.Config.Modules.UserManagement.CorpPhotos.Import.LogFile
			New-LogEntry $Log "for setting corp photos" -JobType "Photo Import" -Console
			
			#Format variables from byte stream
			if ($PSCmdlet.ParameterSetName -eq "FromByte") {
				$ADPhoto = $ADByte
				$O365Photo = $O365Byte
				Add-ToLog $Log "Byte arrays provided as input" -Type INF
			}
			
			#Format variables from file
			if ($PSCmdlet.ParameterSetName -eq "FromFile") {
				try {
					$ADPhoto = [byte[]](Get-Content $ADFile -Encoding byte)
					$O365Photo = [byte[]](Get-Content $O365File -Encoding byte)
					Add-ToLog $Log "The files ($ADFile and $O365File) were provided as input" -Type INF
				} catch {
					Add-ToLog $Log "Could not convert one of the files ($ADFile or $O365File) to a byte array" -ErrorMessage $_.Exception.Message -Type ERR -Console
				}
			}
			
			#Connect to O365 for import
			Connect-CorpO365
			$Result = $False
			$ADResult = $False
			$O365Result = $False
		}
		PROCESS {
			#Get ADUser
			$UserAD = Get-ADUser $User -Properties thumbnailPhoto
			if ($UserAD) {
				Add-ToLog $Log "Located $User in AD. Processing uploads" -Type INF
				
				#Set AD photo
				try {
					Set-ADUser $User -Replace @{ thumbnailPhoto = $ADPhoto } -ErrorAction Stop
					Add-ToLog $Log "AD photo was changed for $User" -Type INF
					$ADResult = $True
				} catch {
					Add-ToLog $Log "Could not change the thumbnail photo for $User" -ErrorMessage $_.Exception.Message -Type ERR -Console
				}
				
				#Set O365 photo
				try {
					Set-UserPhoto $UserAD.UserPrincipalName -PictureData $O365Photo -Confirm:$FALSE -ErrorAction Stop
					Add-ToLog $Log "O365 photo was changed for $User" -Type INF
					$O365Result = $True
				} catch {
					Add-ToLog $Log "Could not change the O365 photo for $User" -ErrorMessage $_.Exception.Message -Type ERR -Console
				}
			} else {
				Add-ToLog $Log "Could not locate $User in AD. Skipping uploads" -Type ERR -Console
			}
		}
		END {
			if ($ADResult -and $O365Result) {
				$Result = $True
			}
			return $Result
		}
	}
	
	Function Add-MailForwarding {
	    <#
	    .SYNOPSIS
	        Alters the SMTP addresses of the supplied users
	    .DESCRIPTION
	        This function is used to set forwarding on user accounts. It will remove the primary
	        SMTP from ToUser and add a secondary smtp to FromUser.
	    .PARAMETER ToUser
	        This is the SAMAccountName of the user that will have emails redirected
	    .PARAMETER FromUser
	        This is the SAMAccountName of the user that will have emails forwarded to them
	    .EXAMPLE
	        Add-MailForwarding -FromUser SAMAccountName -ToUser SAMAccountName
	    .LINK
	    .NOTES
	    #>
		[CmdletBinding()]
		param (
			[Parameter(Mandatory = $True, ValueFromPipeline = $False)]
			[String]$ToUser,
			[String]$FromUser
		)
		BEGIN {
			#Initiate logging
			[xml]$config = Get-OTConfig
			$Log = $config.Config.Globals.LogRoot + $config.Config.Modules.UserManagement.MailForwarding.LogFile
			New-LogEntry $Log "for forwarding $FromUser emails to $ToUser" -JobType "Addition"
		}
		PROCESS {
			#Populate AD Variables
			try {
				if ($FromUser -notmatch "@") { $FromUserAD = Get-ADUser $FromUser -Properties Manager, SamAccountName, EmailAddress | Select Manager, SamAccountName, EmailAddress }
				$ToUserAD = Get-ADUser $ToUser -Properties Manager, SamAccountName, EmailAddress | Select Manager, SamAccountName, EmailAddress -ErrorAction Stop
				Add-ToLog $Log "Located both $FromUser and $ToUser accounts in Active Directory" -Type INF
			} catch {
				Add-ToLog $Log "Could not locate one or both users in Active Directory" -ErrorMessage $_.Exception.Message -Type ERR -Console
			}
			
			
			#Set Manager's proxy
			try {
				if ($FromUser -match "@") { $Address = "smtp:$FromUser" } else { $Address = "smtp:$($FromUserAD.EmailAddress)" }
				Set-ADUser $ToUserAD.SamAccountName -Add @{ ProxyAddresses = $Address } -Confirm:$False -ErrorAction Stop
				Add-ToLog $Log "Added $Address as a proxy address on $($ToUserAD.SamAccountName)" -Type INF
			} catch {
				Add-ToLog $Log "Could not set proxy address $($ToUserAD.SamAccountName) to $($FromUserAD.EmailAddress) in Active Directory" -ErrorMessage $_.Exception.Message -Type ERR -Console
			}
			
			#Remove SMTP from FromUser
			try {
				if ($FromUser -match "@") { $RemoveAddress = "SMTP:$FromUser" } else { $RemoveAddress = "SMTP:$($FromUserAD.EmailAddress)" }
				Set-ADUser $FromUserAD.SamAccountName -Remove @{ ProxyAddresses = $RemoveAddress }
				Add-ToLog $Log "Removed $RemoveAddress from $($FromUserAD.SamAccountName)" -Type INF
			} catch {
				Add-ToLog $Log "Could not remove $RemoveAddress from $($FromUserAD.SamAccountName)" -Type ERR -Console
			}
		}
		END {
		}
	}
	
	Function Remove-MailForwarding {
	    <#
	    .SYNOPSIS
	        Alters the SMTP addresses of the supplied users
	    .DESCRIPTION
	        This function is used to remove forwarding on user accounts. It will remove the 
	        secondary smtp from ToUser and add the primary SMTP to FromUser.
	    .PARAMETER ToUser
	        This is the SAMAccountName of the user that will have redirect removed
	    .PARAMETER FromUser
	        This is the SAMAccountName of the user that will have SMTP restored
	    .EXAMPLE
	        Add-MailForwarding -FromUser SAMAccountName -ToUser SAMAccountName
	    .LINK
	    .NOTES
	    #>
		[CmdletBinding()]
		param (
			[Parameter(Mandatory = $True, ValueFromPipeline = $False)]
			[String]$ToUser,
			[String]$FromUser
		)
		BEGIN {
			#Initiate logging
			[xml]$config = Get-OTConfig
			$Log = $config.Config.Globals.LogRoot + $config.Config.Modules.UserManagement.MailForwarding.LogFile
			New-LogEntry $Log "for removing smtp of $FromUser on account $ToUser" -JobType "Removal"
		}
		PROCESS {
			#Populate AD Variables
			try {
				if ($FromUser -notmatch "@") { $FromUserAD = Get-ADUser $FromUser -Properties Manager, SamAccountName, EmailAddress | Select Manager, SamAccountName, EmailAddress }
				$ToUserAD = Get-ADUser $ToUser -Properties Manager, SamAccountName, EmailAddress | Select Manager, SamAccountName, EmailAddress -ErrorAction Stop
				Add-ToLog $Log "Located both $FromUser and $ToUser accounts in Active Directory" -Type INF -Console
			} catch {
				Add-ToLog $Log "Could not locate one or both users in Active Directory" -ErrorMessage $_.Exception.Message -Type ERR -Console
			}
			
			#Set Manager's proxy
			try {
				if ($FromUser -match "@") { $Address = "smtp:$FromUser" } else { $Address = "smtp:$($FromUserAD.EmailAddress)" }
				Set-ADUser $ToUserAD.SamAccountName -Remove @{ ProxyAddresses = $Address } -Confirm:$False
				Add-ToLog $Log "Removed $Address as a proxy address on $($ToUserAD.SamAccountName)" -Type INF -Console
			} catch {
				Add-ToLog $Log "Could not set proxy address for $($ToUserAD.SamAccountName) to $($FromUserAD.EmailAddress) in Active Directory" -ErrorMessage $_.Exception.Message -Type ERR -Console
			}
			
			#Add SMTP to FromUser
			try {
				if ($FromUser -match "@") { $AddAddress = "SMTP:$FromUser" } else { $AddAddress = "SMTP:$($FromUserAD.EmailAddress)" }
				Set-ADUser $FromUserAD.SamAccountName -Add @{ ProxyAddresses = $AddAddress }
				Add-ToLog $Log "Added $AddAddress To $($FromUserAD.SamAccountName)" -Type INF -Console
			} catch {
				Add-ToLog $Log "Could not add $AddAddress to $($FromUserAD.SamAccountName)" -Type ERR -Console -ErrorMessage $_.Exception.Message
			}
		}
		END {
		}
	}
	
	Function Update-UserUPN {
	    <#
	    .SYNOPSIS
	        Detects and sets UPN for users who do not match the standard
	    .DESCRIPTION
	        This function detects users who do not have the current UPN schema and
	        changes them accordingly
	    .PARAMETER Group
	        This is the group name of the AD group that will be targeted for detection
	    .PARAMETER SendEmail
	        This is an optional parameter that can override the default email preference
	    .EXAMPLE
	        Update-UserUPN -Group Azure_Sync -SendEmail
	    .EXAMPLE
	        Update-UserUPN -Group Azure_Sync
	    .LINK
	    .NOTES
	    #>
		[CmdletBinding()]
		Param (
			[Parameter(Mandatory = $True, ValueFromPipeline = $True)]
			[String]$Group,
			[Parameter(Mandatory = $False, ValueFromPipeline = $True)]
			[Switch]$SendEmail
		)
		
		Begin {
			#Initiate logging
			[xml]$config = Get-OTConfig
			$Log = $config.Config.Globals.LogRoot + $config.Config.Modules.UserManagement.UPNUpdate.LogFile
			
			New-LogEntry $Log "for updating user UPNs" -JobType "UPN Update" -Console
		}
		Process {
			#Pull current users with incorrect UPN
			try {
				$UserList = @(Get-ADGroupMember -Identity $Group -Recursive | Get-ADUser | Where-Object { $_.UserPrincipalName -notlike "*@onetechnologies.net" })
				$LogListCount = $UserList.Count
				if ($LogListCount -gt 0) {
					Add-ToLog $Log "Generated a list of $LogListCount users missing UPN updates in group $Group" -Type INF -Console
				} else {
					Add-ToLog $Log "All users have updated UPN" -Type INF -Console
				}
			} catch {
				Add-ToLog $Log "Could not generate user list using the group $Group" -ErrorMessage $_.Exception.Message -Type ERR -Console
			}
			
			#Replace each incorrect UPN
			ForEach ($User in $UserList) {
				$UPN = $User.UserPrincipalName.Replace("@onetech.local", "@onetechnologies.net")
				try {
					Set-ADUser $User.SamAccountName -UserPrincipalName $UPN
					
					#Test that change was a success
					if ((Get-ADUser $User.SamAccountName).UserPrincipalName -eq $UPN) {
						Add-ToLog $Log "User $($User.SamAccountName)'s UPN was updated" -Type INF -Console
					} else {
						throw "The change attempt failed, but a capturable exception was not returned."
					}
				} catch {
					Add-ToLog $Log "User $($User.SamAccountName) could not be updated" -ErrorMessage $_.Exception.Message -Type ERR -Console
				}
			}
		}
		End {
			if (($SendEmail) -and ($LogSuccess -gt 0) -and ($LogFailure -eq 0)) {
				#Send-LogEmail -LogPath $Log -Result Success
			} elseif (($SendEmail) -and ($LogSuccess -gt 0) -and ($LogFailure -gt 0)) {
				Send-LogEmail -LogPath $Log -Result 'Success with exceptions'
			} elseif (($SendEmail) -and ($LogSuccess -eq 0) -and ($LogFailure -gt 0)) {
				Send-LogEmail -LogPath $Log -Result Failure
			}
		}
	}
	
	Function Update-HRInfo {
	    <#
	    .SYNOPSIS
	        Update AD account information based on an export from ExponentHR
	    .DESCRIPTION
	        This function sifts data given to it by an export from ExponentHR
	        and compares it against data from AD. If the HR export has newer data
	        the script will inject the new updates into the AD user object. The
	        function will then add the user to the supplied AD group for tracking
	        purposes. This functionality will be separated at a later date
	    .PARAMETER Group
	        The AD group that the users will be added to once updates have been
	        completed
	    .PARAMETER ImportFile
	        A string path to the CSV data file that has been exported from ExponentHR
	    .EXAMPLE
	        Update-HRInfo -Group TeamUS -ImportFile "\\Path\to\file.csv"
	    .LINK
	    .NOTES
	    #>
		[CmdletBinding()]
		Param (
			[Parameter(Mandatory = $True, ValueFromPipeline = $False)]
			[String]$Group,
			[String]$ImportFile
		)
		
		Begin {
			#Import configuration files and initiate the log file
			[xml]$config = Get-OTConfig
			$Log = $config.Config.Globals.LogRoot + $config.Config.Modules.UserManagement.HRSync.LogFile
			
			#Setup logging variables
			$LogRowChanged = 0
			$LogRowIgnored = 0
			$LogRowFailed = 0
			$LogChangeList = ""
			$NoFile = $false
			New-LogEntry $Log "For updating user AD properties from HR data" -JobType "HR Data Sync" -Console
		}
		Process {
			
			#Check CSV is current
			if (!(Test-Path $ImportFile -OlderThan (Get-Date).AddDays(-2))) {
				Add-ToLog $Log "HR data has been updated within the two day threshold" -Type INF -Console
				
				#Import required files
				try {
					$UserList = Import-Csv $ImportFile
					$SkipList = Get-Content $config.Config.Modules.UserManagement.HRSync.SkipList
					Add-ToLog $Log "Imported HR data source and skip list" -Type INF -Console
				} catch {
					Add-ToLog $Log "Data import could not be completed. Check the location of HR data source and AD user skip list" -ErrorMessage $_.Exception.Message -Type ERR -Console
				}
				
				try {
					$UserADs = Get-ADUser -Filter { Enabled -eq $True } -Properties extensionAttribute1, Title, OfficePhone, Department, Manager, EmailAddress
				} catch {
					Add-ToLog $Log "Could not import current list of users from AD" -ErrorMessage $_.Exception.Message -Type ERR -Console
				}
				
				#Start CSV parse
				Add-ToLog $Log "Starting search for employees requiring updates..." -Type INF -Console
				ForEach ($User in $UserList) {
					
					#Check if user is part of the skip list
					if ((!($SkipList | ?{ $_ -eq $User.'Work Email Address' }))) {
						
						#Check that accounts have both manager and user email addresses
						if (($User.'Work Email Address' -match "@") -and ($User.'Supervisor Email' -match "@")) {
							
							#Format number and start the arguments variable
							$FormattedNumber = $User.'Work Phone' -replace "/", "-"
							$args = ""
							
							#Try to match AD objects against CSV data
							try {
								$UserAD = $UserADs | ? { $_.emailaddress -eq $($User.'Work Email Address') }
								if ($UserAD -eq $null) { throw "The employee email address $($User.'Work Email Address') did not match an AD object" }
								$managerAD = $UserADs | ?{ $_.emailaddress -eq $($User.'Supervisor Email') }
								if ($managerAD -eq $null) { throw "The supervisor email address $($User.'Supervisor Email') did not match an AD object" }
								
								#Build arguments list if no errors are thrown, only changing rows that are mismatched
								if ($UserAD.Manager -notlike $managerAD.DistinguishedName) { $args += " -Manager $($managerAD.SamAccountName)" }
								if (($UserAD.Title -notlike $User.'Job Title') -and ($User.'Job Title')) { $args += " -Title '$($User.'Job Title')'" }
								if (($UserAD.OfficePhone -notlike $FormattedNumber) -and ($FormattedNumber)) { $args += " -OfficePhone '$($FormattedNumber)'" }
								if (($UserAD.Department -notlike $User.Department) -and ($User.Department)) { $args += " -Department '$($User.'Department')'" }
								if ($UserAD.extensionAttribute1 -eq $null) { $args += " -Add @{extensionAttribute1='$($User.'Original Hire Date')'}" }
							} catch {
								$LogRowFailed++
								Add-ToLog $Log "Failed to match $($User.'First Name') $($User.'Last Name')" -ErrorMessage $_.Exception.Message -Type ERR -Console
							}
							try {
								#Check if arguments are supplied and run update
								if ($args) {
									Add-ToLog $Log "Changes detected for $($UserAD.SamAccountName). The update expression is `"Set-ADUser -Identity $($UserAD.SamAccountName)$Args`"" -Type INF
									Invoke-Expression "Set-ADUser -Identity $($UserAD.SamAccountName) $args"
									$LogChangeList += " ,$($UserAD.SamAccountName)"
									$LogRowChanged++
								} else {
									$LogRowIgnored++
								}
								
							} catch {
								$LogRowFailed++
								Add-ToLog $Log "Failed to update user $($User.'First Name') $($User.'Last Name')" -ErrorMessage $_.Exception.Message -Type ERR -Console
							}
							
							#Add user to DL
							try {
								if (!(Get-ADGroupMember $Group | Where-Object { $_.SamAccountName -eq $UserAD.SamAccountName }) -and ($UserAD)) {
									Add-ADGroupMember $Group -Members $UserAD.SamAccountName
									Add-ToLog $Log "$($UserAD.SamAccountName) was added to $Group" -Type INF
								}
							} catch {
								$LogRowFailed++
								Add-ToLog $Log "User $($User.'First Name') $($User.'Last Name') could not be added to $Group" -ErrorMessage $_.Exception.Message -Type ERR -Console
							}
						} else {
							$LogRowFailed++
							Add-ToLog $Log "User $($User.'First Name') $($User.'Last Name') does not have a work email or manager email associated with the acocunt" -Type ERR -Console
						}
					} else {
						$LogRowIgnored++
						Add-ToLog $Log "User $($User.'First Name') $($User.'Last Name') is a member of the skip list" -Type INF -Console
					}
				}
			} else {
				$NoFile = $True
				Add-ToLog $Log "The file has not been updated within the two day threshold" -Type INF -Console
			}
		}
		End {
			#Print captured data to log
			if ($LogRowChanged -ge 1) { $LogChangeList = $LogChangeList.substring(2) } else { $LogChangeList = "None" }
			Add-ToLog $Log "$LogRowChanged rows were changed" -Type INF -Console
			Add-ToLog $Log "$($LogRowIgnored - $LogRowChanged - $LogRowFailed) rows were ignored" -Type INF -Console
			Add-ToLog $Log "$LogRowFailed rows attempted change and failed" -Type INF -Console
			Add-ToLog $Log "Account changed: $LogChangeList" -Type INF -Console
			if (($LogRowChanged -ge 1) -and ($LogRowFailed -eq 0)) {
				#Send-LogEmail -LogPath $Log -Result Success
			} elseif (($LogRowChanged -ge 1) -and ($LogRowFailed -gt 0)) {
				Send-LogEmail -LogPath $Log -Result 'Success with exceptions'
			} elseif (($LogRowChanged -eq 0) -and ($LogRowIgnored -gt 0) -and ($LogRowFailed -eq 0)) {
				#Send-LogEmail -LogPath $Log -Result Success
			} elseif (($LogRowChanged -eq 0) -and ($LogRowIgnored -ge 1) -and ($LogRowFailed -gt 1)) {
				Send-LogEmail -LogPath $Log -Result 'Success with exceptions'
			} elseif ($NoFile) {
				#Send-LogEmail -LogPath $Log -Result Success
			} else {
				Send-LogEmail -LogPath $Log -Result Failure
			}
		}
	}
	
	Function Update-CorpPhotos {
		[CmdletBinding()]
		Param (
			[Parameter(Mandatory = $True, ValueFromPipeline = $False, ValueFromPipelineByPropertyName = $False)]
			[String]$SourcePath = "",
			[String]$Days = "",
			[Parameter(Mandatory = $False, ValueFromPipeline = $False, ValueFromPipelineByPropertyName = $False)]
			[String]$Credentials
		)
		
		Begin {
			#Config and Error handling
			[xml]$config = Get-OTConfig
			$Log = $config.Config.Globals.LogRoot + $Config.Config.Modules.UserManagement.CorpPhotos.Process.LogFile
			New-LogEntry $Log "for updating corporate photos" -JobType "Photo Manipulation" -Console
			
			#Working Variables
			$WorkingPath = $config.Config.Scripts.PhotoSync.Input
			$TypeFilter = "*.jpg"
			$ModifiedAge = (get-date).Adddays(- $Days)
			$WidthPx = 96
			$HeightPx = 96
			$SkypeWidthPx = 648
			$SkypeHeightPx = 648
			
			#Initiate O365 connection
			Write-ToConsole "Detecting and closing open sessions to mitigate issues associated with allowClobber" -Type INF
			Disconnect-CorpExchange
			Disconnect-CorpO365
			Connect-CorpO365 -Credentials $Creds
			
			#Set files count to 0
			$LocalFilesCount = 0
			$NetworkFilesCount = 0
			$AllFilesCount = 0
			
			#Load required powershell Sessions and arrays
			[Reflection.Assembly]::LoadWithPartialName("System.Windows.Forms") | Out-Null
			
			
			#Create working directories
			if (!(Test-Path -PathType Container $WorkingPath)) {
				New-Item $WorkingPath -type Directory
				New-Item "$WorkingPath\Exported" -type Directory
				New-Item "$WorkingPath\Imported" -type Directory
				New-Item "$WorkingPath\Failed" -type Directory
			}
			
			#Gather Local files
			$LocalFiles = Get-ChildItem -Path $WorkingPath -filter $TypeFilter | ?{ !$_.PSIsContainer } | where-object { $_.LastWriteTime -gt $ModifiedAge }
			$LocalCount = $LocalFiles | measure-object
			$LocalFilesCount = $LocalCount.count
			
			if ($LocalFilesCount -gt 0) {
				foreach ($LocalFile in $LocalFiles) {
					$LocalName = [io.path]::GetFileNameWithoutExtension($LocalFile)
					$LocalFilesNames += "$LocalName, "
				}
			}
			
			#Gather Network Files
			$NetworkFiles = get-childitem -Path $SourcePath -filter $TypeFilter | ?{ !$_.PSIsContainer } | where-object { $_.LastWriteTime -gt $ModifiedAge }
			$NetworkCount = $NetworkFiles | measure-object
			$NetworkFilesCount = $NetworkCount.count
			if ($NetworkFilesCount -gt 0) {
				foreach ($NetworkFile in $NetworkFiles) {
					$NetworkName = [io.path]::GetFileNameWithoutExtension($NetworkFile)
					$NetworkFilesNames += "$NetworkName, "
				}
				$NetworkFiles | copy-item -destination $WorkingPath
			}
		}
		
		Process {
			$AllFilesCount = $LocalFilesCount + $NetworkFilesCount
			
			if ($AllFilesCount -gt 0) {
				$AllFiles = get-childitem -Path $WorkingPath -filter $TypeFilter | ?{ !$_.PSIsContainer }
				
				#Process files
				foreach ($File in $AllFiles) {
					Add-ToLog $Log "`"$File`" is a newly added file" -Type INF
					
					#Confirm Photos match Active Directory Username
					$Name = [io.path]::GetFileNameWithoutExtension($File)
					
					#Locate user in AD
					try {
						$ADUser = Get-ADUser -Filter { SamAccountName -eq $Name } -Properties ThumbnailPhoto
						Add-ToLog $Log "Located $($ADUser.SamAccountName) in AD. Processing image" -Type INF -Console
					} catch {
						Add-ToLog $Log "$Name did not match a user object in AD" -ErrorMessage $_.Exception.Message -Type ERR -Console
					}
					
					#Process user
					if ($ADUser) {
						#Detect and export existing AD photo
						if ($ADUser.thumbnailPhoto) {
							$FileStamp = "$Name $(get-date -f yyyy-MM-dd-HH-mm-ss).jpg"
							Add-ToLog $Log "Detected existing thumbnail photo. Exporting current photo to `"$WorkingPath\Exported\$FileStamp`"" -Type INF
							try {
								$ADUser.thumbnailphoto | Set-Content ("$WorkingPath\Exported\$FileStamp") -Encoding byte -ErrorAction Stop
							} catch {
								Add-ToLog $Log "Could not export photo for $($ADUser.SamAccountName)" -ErrorMessage $_.Exception.Message -Type ERR -Console
							}
							
							if (Test-Path "$WorkingPath\Exported\$FileStamp") {
								Add-ToLog $Log "Export successful" -Type INF
							} else {
								Add-ToLog $Log "Export was not successful, but no error was thrown" -Type ERR -Console
							}
						}
						
						#Detect and export existing Skype photo
						$SkypeUser = Get-UserPhoto $ADUser.UserPrincipalName
						if ($SkypeUser.PictureData) {
							$SkypeFileStamp = "$Name $(get-date -f yyyy-MM-dd-HH-mm-ss)Skype.jpg"
							Add-ToLog $Log "Detected existing Skype photo. Exporting current photo to `"$WorkingPath\Exported\$SkypeFileStamp`"" -Type INF
							try {
								$SkypeUser.PictureData | Set-Content ("$WorkingPath\Exported\$SkypeFileStamp") -Encoding byte
							} catch {
								Add-ToLog $Log "Could not export photo for $($ADUser.SamAccountName)" -ErrorMessage $_.Exception.Message -Type ERR -Console
							}
							
							if (Test-Path "$WorkingPath\Exported\$SkypeFileStamp") {
								Add-ToLog $Log "Export was successful" -Type INF
							} else {
								Add-ToLog $Log "Export was not successful, but no error was thrown" -Type ERR -Console
							}
						}
						
						Add-ToLog $Log "Crunching image data" -Type INF
						#Change ratio of old image to a square
						Add-ToLog $Log "Starting photo format for $($ADUser.SamAccountName)" -Type INF
						$OldImageRect = New-Object System.Drawing.Bitmap "$WorkingPath\$File"
						$OldImageSq = New-Object System.Drawing.Bitmap $OldImageRect.Width, $OldImageRect.Width
						$Graphics = [System.Drawing.Graphics]::FromImage($OldImageSq)
						$Graphics.InterpolationMode = [System.Drawing.Drawing2D.InterpolationMode]::HighQualityBicubic
						
						#Determine square dimensions of origin photo
						$RatioAdjustment = $OldImageRect.width - $OldImageRect.height
						$SqDim = $OldImageRect.width
						
						#Draw ratio of old image to square
						$Graphics.DrawImage($OldImageRect, 0, $RatioAdjustment, $SqDim, ($SqDim - $RatioAdjustment))
						
						#Determine new AD dimensions
						$OldWidth = $OldImageSq.Width
						$OldHeight = $OldImageSq.Height
						
						if ($OldWidth -lt $OldHeight) {
							$NewWidth = $WidthPx
							[int]$NewHeight = [Math]::Round(($NewWidth * $OldHeight)/$OldWidth)
							
							if ($NewHeight -gt $HeightPx) {
								$NewHeight = $HeightPx
								[int]$NewWidth = [Math]::Round(($NewHeight * $OldWidth)/$OldHeight)
							}
						} else {
							$NewHeight = $HeightPx
							[int]$NewWidth = [Math]::Round(($NewHeight * $OldWidth)/$OldHeight)
							
							if ($NewWidth -gt $WidthPx) {
								$NewWidth = $WidthPx
								[int]$NewHeight = [Math]::Round(($NewWidth * $OldHeight)/$OldWidth)
							}
						}
						
						#Resize Working Image to 96x96
						$NewImage = new-object System.Drawing.Bitmap $NewWidth, $NewHeight
						$Graphics = [System.Drawing.Graphics]::FromImage($NewImage)
						$Graphics.InterpolationMode = [System.Drawing.Drawing2D.InterpolationMode]::HighQualityBicubic
						$Graphics.DrawImage($OldImageSq, 0, 0, $NewWidth, $NewHeight)
						
						#Resize Working Image to 648x648
						$NewSkypeImage = new-object System.Drawing.Bitmap $SkypeWidthPx, $SkypeHeightPx
						$SkypeGraphics = [System.Drawing.Graphics]::FromImage($NewSkypeImage)
						$SkypeGraphics.InterpolationMode = [System.Drawing.Drawing2D.InterpolationMode]::HighQualityBicubic
						$SkypeGraphics.DrawImage($OldImageSq, 0, 0, $SkypeWidthPx, $SkypeHeightPx)
						
						#Save Working Image
						$ImageFormat = $OldImageSq.RawFormat
						$OldImageSq.Dispose()
						$OldImageRect.Dispose()
						try {
							$NewImage.Save("$WorkingPath\$File", $ImageFormat)
							Add-ToLog $Log "Saving new working image to `"$WorkingPath\$File`"" -Type INF
						} catch {
							Add-ToLog $Log "Could not save working image to `"$WorkingPath\$File`"" -ErrorMessage $_.Exception.Message -Type ERR -Console
						}
						try {
							$NewSkypeImage.Save("$WorkingPath\Skype-$File", $ImageFormat)
							Add-ToLog $Log "Saving new working image to `"$WorkingPath\Skype-$File`"" -Type INF
						} catch {
							Add-ToLog $Log "Could not save working image to `"$WorkingPath\Skype-$File`"" -ErrorMessage $_.Exception.Message -Type ERR -Console
						}
						$NewImage.Dispose()
						$NewSkypeImage.Dispose()
						
						#Process imports
						$ADPhoto = [byte[]](Get-Content "$WorkingPath\$File" -Encoding byte)
						$SkypePhoto = [byte[]](Get-Content "$WorkingPath\Skype-$File" -Encoding Byte)
						$ImportResult = Set-CorpPhotos -ADByte $ADPhoto -O365Byte $SkypePhoto -User $ADUser.SamAccountName
						
						if ($ImportResult) {
							#Save an AD copy as Imported
							try {
								$FileStamp = "$Name $(Get-Date -f yyyy-MM-dd-HH-mm-ss)-96x96.jpg"
								Move-Item "$WorkingPath\$File" "$WorkingPath\imported\$FileStamp" -Force
							} catch {
								Add-ToLog $Log "Failed moving $FileStamp" -ErrorMessage $_.Exception.Message -Type ERR -Console
							}
							
							#Save a Skype copy as Imported
							try {
								$SkypeFileStamp = "$Name $(Get-Date -f yyyy-MM-dd-HH-mm-ss)-648x648.jpg"
								Move-Item "$WorkingPath\Skype-$File" "$WorkingPath\imported\$SkypeFileStamp" -Force
							} catch {
								Add-ToLog $Log "Failed moving $SkypeFileStamp" -ErrorMessage $_.Exception.Message -Type ERR -Console
							}
						} else {
							Add-ToLog $Log "Import failed for $User. See import log ($($config.Config.Globals.LogRoot + $config.Config.Modules.UserManagement.CorpPhotos.Import.LogFile)) for details of failure" -Type INF -Console
						}
					} Else {
						#Delete Working Image
						$FileStamp = "$Name $(get-date -f yyyy-MM-dd-HH-mm-ss).jpg"
						Add-ToLog $Log "Could not locate user in AD. Moving $FileStamp to failed foler" -Type WRN -Console
						Move-Item "$WorkingPath\$File" "$WorkingPath\failed\$FileStamp" -force
					}
				}
			}
		}
		
		End {
			
			#Send Email Log
			if (($SendEmailLog -eq $TRUE) -and ($SuccessCount -gt 0) -and ($FailCount -eq 0)) {
				#Send-LogEmail -LogPath $Log -Result Success
			} elseif (($SendEmailLog -eq $TRUE) -and ($AllFilesCount -gt 0) -and ($FailCount -gt 1) -and ($SuccessCount -gt 1)) {
				Send-LogEmail -LogPath $Log -Result 'Success with exceptions'
			} elseif (($SendEmailLog -eq $TRUE) -and ($SuccessCount -eq 0) -and ($FailCount -eq 0)) {
				#Send-LogEmail -LogPath $Log -Result Success
			} else {
				Send-LogEmail -LogPath $Log -Result Failure
			}
		}
	}
	
	Function Enable-MailboxSync {
		[CmdletBinding()]
		Param (
			[Parameter(Mandatory = $True, ValueFromPipeline = $True)]
			[Microsoft.ActiveDirectory.Management.ADUser]$User
		)
		Begin {
			#Config and logging
			[xml]$Config = Get-OTConfig
			$Log = $Config.Config.Globals.LogRoot + $Config.Config.Modules.UserManagement.MailSync.LogFile
			
			#Logging
			New-LogEntry $Log "for enabling excahnge remote mailbox sync" -JobType "Remote Mailbox Enable" -Console
			
			Connect-CorpExchange
			
			#Function Variables
			$MailList = Get-RemoteMailbox -WarningAction silentlycontinue | ?{ $_.DistinguishedName -notmatch "Disabled Users" }
			$Changes = $False
		}
		Process {
			#Check if each user has mail enabled and enable mail
			if (!($MailList | ?{ $_.SamAccountName -eq $User.SamAccountName })) {
				$Changes = $True
				Add-ToLog $Log "User $($User.SamAccountName)'s email mapping is not formated for syncing" -Type INF -Console
				
				#Format O365 user email address and enable mailbox
				$O365Email = "$($User.SamAccountName)@onetechnologiesO365.mail.onmicrosoft.com"
				try {
					Enable-RemoteMailbox $User.SamAccountName -RemoteRoutingAddress $O365Email | Out-Null
					Add-ToLog $Log "User $($User.SamAccountName)'s email mapping has been updated to $O365Email" -Type INF -Console
				} catch {
					Add-ToLog $Log "Could not update $($User.SamAccountName)'s email to $O365Email" -ErrorMessage $_.Exception.Message -Type ERR -Console
				}
				
				#Add temporary ExtensionAttribute2 flag in AD for Add-O365License
				try {
					Set-ADUser -Identity $User.SamAccountName -Add @{ extensionAttribute2 = 'LICENSE_REQUIRED' }
					Add-ToLog $Log "User $($User.SamAccountName) has had extentionAttribute2 set" -Type INF -Console
				} catch {
					Add-ToLog $Log "Could not set extensionAttribute2 for user $($User.SamAccountName)" -ErrorMessage $_.Exception.Message -Type ERR -Console
				}
			}
		}
		End {
			#Logging
			if (!$Changes) {
				Add-ToLog $Log "All users have remote mailbox enabled" -Type INF -Console
			}
		}
	}
	
	
	Export-ModuleMember -Function Get-OPSUserManagementVersion,
						Revoke-UserAccess,
						Restore-UserAccess,
						New-UserAccess,
						Set-O365License,
						Get-O365License,
						Get-CorpPhotos,
						Set-CorpPhotos,
						Add-MailForwarding,
						Remove-MailForwarding,
						Update-UserUPN,
						Update-HRInfo,
						Update-CorpPhotos,
						Enable-MailboxSync